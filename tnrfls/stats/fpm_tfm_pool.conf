;[ SCRIPT ] -> [ INTERPRETER WORKER ] --(Web)--> [ WEB SERVER ]
;                      | (Log Stream)
;              [ GLOBAL MASTER ] ----(fd/2)---> [ PODMAN LOGS ]
;
;confusing but worker pool says how self should be managed, then global manages accordingly
;called inversion-of-control pattern / manager-managed design

; define global manager, a c process
[global]
; send logs to the stderr for podman to collect
error_log = /proc/self/fd/2

; define pool of workers, processes running interpreters
[tfm_pool]
user = root
group = root

; listen for traffic
listen = auth:9000

; don't clear environment variables for processes
clear_env = no

; don't leak info once in production, but do log to podman
php_admin_flag[display_errors] = off
catch_workers_output = yes
decorate_workers_output = no
;explicit, but not necessary
;php_admin_flag[log_errors] = on
;php_admin_value[error_log] = /proc/self/fd/2


; manage max request sizes
php_admin_value[memory_limit] = 256M
php_admin_value[post_max_size] = 2056M
php_admin_value[upload_max_filesize] = 2048M

; allow uploads up to 10min, plenty for <=2gb, and post processing execution up to 3min
php_admin_value[max_input_time] = 600
php_admin_value[max_execution_time] = 180

; kill upload/download processes running past 14min
request_terminate_timeout = 840

; limit process creation & keep most idle processes around for 5min while browsing, but then quickly killed
pm = ondemand
pm.max_children = 2
pm.process_idle_timeout = 300s

; close inactive sessions after 5min
php_admin_value[session.gc_maxlifetime] = 900
php_admin_value[session.gc_probability] = 25
